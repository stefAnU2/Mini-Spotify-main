<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <title>Reproductor</title>
    <style>
      :root {
        --verde: #1db954;
        --bg: #0f0f0f;
        --panel: #1a1a1a;
        --text: #fff;
      }
      html,
      body {
        margin: 0;
        padding: 10px;
        background: var(--bg);
        color: var(--text);
        font-family: Arial, sans-serif;
      }
      .player-wrap {
        display: flex;
        gap: 12px;
        align-items: center;
        height: 100%;
      }

      /* Left: thumbnail */
      .thumb {
        width: 88px;
        height: 88px;
        border-radius: 8px;
        background: linear-gradient(180deg, #222, #111);
        display: flex;
        align-items: center;
        justify-content: center;
        overflow: hidden;
        flex-shrink: 0;
      }
      .thumb img {
        width: 100%;
        height: 100%;
        object-fit: cover;
        display: block;
      }

      /* Right: info + barra + controles */
      .right {
        flex: 1;
        display: flex;
        flex-direction: column;
        min-width: 0;
      }

      /* T√≠tulo arriba */
      .title {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        padding: 2px 6px;
        min-height: 32px;
      }
      .title .titulo {
        font-weight: 700;
        font-size: 14px;
        text-align: center;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        width: 100%;
      }
      .title .subtitulo {
        font-size: 12px;
        color: #dcdcdc;
        margin-top: 4px;
        opacity: 0.9;
      }

      /* Centro: barra */
      .center {
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 6px 8px;
      }
      .time {
        font-size: 12px;
        width: 44px;
        text-align: center;
        color: #fff;
        opacity: 0.9;
      }
      #progreso {
        flex: 1;
        appearance: none;
        height: 8px;
        border-radius: 8px;
        background: #444;
        outline: none;
        min-width: 140px;
      }
      #progreso::-webkit-slider-runnable-track {
        height: 8px;
        border-radius: 8px;
        background: linear-gradient(
          to right,
          var(--verde) var(--value, 0%),
          #444 var(--value, 0%)
        );
      }
      #progreso::-webkit-slider-thumb {
        -webkit-appearance: none;
        width: 14px;
        height: 14px;
        background: var(--verde);
        border-radius: 50%;
        margin-top: -3px;
      }
      /* Firefox */
      #progreso::-moz-range-track {
        height: 8px;
        background: #444;
        border-radius: 8px;
      }
      #progreso::-moz-range-progress {
        background: var(--verde);
        height: 8px;
        border-radius: 8px;
      }
      #progreso::-moz-range-thumb {
        width: 14px;
        height: 14px;
        background: var(--verde);
        border-radius: 50%;
        border: none;
      }

      /* Controles abajo */
      .controls {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 18px;
        padding-top: 6px;
      }
      .controls button {
        background: none;
        border: none;
        color: var(--text);
        font-size: 20px;
        cursor: pointer;
        padding: 6px;
        border-radius: 6px;
      }
      .controls button:hover {
        color: var(--verde);
        transform: scale(1.08);
      }

      /* Volumen: oculto salvo hover */
      .volumen {
        display: flex;
        align-items: center;
        gap: 6px;
        margin-left: 8px;
        position: relative;
        color: #1db954;
      }
      .volumen input[type="range"] {
        width: 0;
        opacity: 0;
        pointer-events: none;
        transition: width 0.18s ease, opacity 0.12s ease;
      }
      .volumen:hover input[type="range"],
      .volumen input[type="range"]:focus {
        width: 100px;
        opacity: 1;
        pointer-events: auto;
      }
      .muted {
        font-size: 11px;
        color: #ccc;
        text-align: center;
        margin-top: 4px;
        opacity: 0.9;
      }

      /* Make sure everything is vertically aligned in small heights */
      @media (max-width: 420px) {
        .player-wrap {
          gap: 8px;
        }
        .thumb {
          width: 72px;
          height: 72px;
        }
        .title .titulo {
          font-size: 13px;
        }
        .controls button {
          font-size: 18px;
        }
      }
    </style>
  </head>
  <body>
    <div class="player-wrap">
      <!-- THUMB -->
      <div class="thumb" id="thumb">
        <img id="thumbImg" src="" alt="thumbnail" />
      </div>

      <!-- RIGHT: title + barra + controls -->
      <div class="right">
        <div class="title">
          <div class="titulo" id="tituloCancion">
            No se est√° reproduciendo ninguna canci√≥n
          </div>
          <div class="subtitulo" id="subtitulo">-</div>
        </div>

        <div class="center">
          <div class="time" id="tiempo-actual">0:00</div>
          <input
            type="range"
            id="progreso"
            value="0"
            min="0"
            max="1"
            step="0.01"
          />
          <div class="time" id="tiempo-total">0:00</div>
        </div>

        <div class="controls">
          <button id="prevBtn" title="Anterior">‚èÆ</button>
          <button id="playPauseBtn" title="Play/Pausa">‚ñ∂</button>
          <button id="nextBtn" title="Siguiente">‚è≠</button>

          <div class="volumen" title="Volumen">
            <span>üîä</span>
            <input
              type="range"
              id="volumenControl"
              min="0"
              max="1"
              step="0.01"
              value="1"
            />
          </div>
        </div>

        <div class="muted" id="sub"></div>
      </div>
    </div>

    <!-- audio (sin controls nativos) -->
    <audio id="player" preload="metadata"></audio>

    <!-- cat√°logo opcional -->
    <script src="canciones.js"></script>

    <script>
      (function () {
        // UI
        const audio = document.getElementById("player");
        const tituloEl = document.getElementById("tituloCancion");
        const subt = document.getElementById("subtitulo");
        const sub = document.getElementById("sub");
        const thumbImg = document.getElementById("thumbImg");
        const progreso = document.getElementById("progreso");
        const tActual = document.getElementById("tiempo-actual");
        const tTotal = document.getElementById("tiempo-total");
        const playPauseBtn = document.getElementById("playPauseBtn");
        const nextBtn = document.getElementById("nextBtn");
        const prevBtn = document.getElementById("prevBtn");
        const volumenControl = document.getElementById("volumenControl");

        // === HISTORIAL para modo radio (contenido.html) ===
        let radioHistory = []; // guardar√° tracks (objetos) en orden de reproducci√≥n
        let radioIndex = -1; // puntero al track actual dentro de radioHistory
        // Nota: radioHistory[radioIndex] es el track actual (si radioIndex >= 0)

        // estado
        let currentPlaylist = [];
        let currentIndex = 0;
        let isPlaylist = false;
        let wrap = false;

        // helpers
        function fmtTitle(track) {
          const t = (track?.titulo || "(sin t√≠tulo)").trim();
          const a = (track?.artista || "").trim();
          return a ? `${t} ‚Äî ${a}` : t;
        }
        function setUIForTrack(track) {
          tituloEl.textContent = fmtTitle(track);
          subt.textContent = track?.artista || "";
          sub.textContent = track?.ruta || "";
          thumbImg.src =
            track?.thumbnail ||
            'data:image/svg+xml;charset=UTF-8,<svg xmlns="http://www.w3.org/2000/svg" width="88" height="88"><rect fill="%231a1a1a" width="100%" height="100%"/></svg>';
        }
        function format(sec) {
          if (!isFinite(sec) || sec <= 0) return "0:00";
          sec = Math.floor(sec);
          return Math.floor(sec / 60) + ":" + String(sec % 60).padStart(2, "0");
        }

        // robust playTrack: encode path, load, catch play() promise
        function playTrack(track, options = { fromHistory: false }) {
          if (!audio) return;
          if (!track || !track.ruta) {
            tituloEl.textContent = "Archivo de audio no disponible";
            sub.textContent = "";
            audio.pause();
            audio.removeAttribute("src");
            audio.load();
            return;
          }

          // encode path (relative paths): encode segments to preserve slashes
          let src = String(track.ruta || "").trim();
          if (!/^[a-zA-Z]+:\/\//.test(src)) {
            src = src
              .split("/")
              .map((s) => encodeURIComponent(s))
              .join("/");
          } else {
            try {
              src = encodeURI(src);
            } catch (e) {
              console.warn(e);
            }
          }

          console.info("playTrack -> src:", src);
          audio.pause();
          audio.src = src;
          audio.load();
          setUIForTrack(track);

          // HISTORIAL (solo en modo radio i.e. !isPlaylist) salvo que venga fromHistory = true
          if (!isPlaylist && !options.fromHistory) {
            // si navegamos hacia adelante despu√©s de haber retrocedido, cortamos el forward
            if (radioIndex < radioHistory.length - 1) {
              radioHistory = radioHistory.slice(0, radioIndex + 1);
            }
            const last = radioHistory[radioHistory.length - 1];
            if (!last || last.ruta !== track.ruta) {
              radioHistory.push(track);
              radioIndex = radioHistory.length - 1;
            } else {
              // si el √∫ltimo ya es la misma ruta, simplemente sincronizamos radioIndex
              radioIndex = radioHistory.length - 1;
            }
          } else if (!isPlaylist && options.fromHistory) {
            // estamos reproduciendo desde historial: buscar posici√≥n correspondiente
            const idx = radioHistory.findIndex((r) => r.ruta === track.ruta);
            if (idx >= 0) radioIndex = idx;
          }

          audio
            .play()
            .then(() => {
              // ok
            })
            .catch((err) => {
              console.warn("play err", err);
              if (err && err.name === "NotSupportedError") {
                tituloEl.textContent =
                  "Formato no soportado o fuente inaccesible";
                sub.textContent = src;
              }
            });
        }

        function playFromPlaylist(index) {
          if (!currentPlaylist?.length) return;
          currentIndex = Math.max(
            0,
            Math.min(index, currentPlaylist.length - 1)
          );
          isPlaylist = true;
          playTrack(currentPlaylist[currentIndex]);
        }

        // --- audio events ---
        audio.addEventListener("loadedmetadata", () => {
          const d = audio.duration;
          progreso.max = isFinite(d) && d > 0 ? d : 1;
          tTotal.textContent = isFinite(d) && d > 0 ? format(d) : "0:00";
          progreso.value = 0;
          progreso.style.setProperty("--value", "0%");
          // notify parent about needed height (postMessage)
          requestParentResize();
        });

        audio.addEventListener("timeupdate", () => {
          if (!isFinite(audio.duration) || audio.duration === 0) return;
          const cur = audio.currentTime;
          progreso.value = cur;
          const pct = (cur / audio.duration) * 100;
          progreso.style.setProperty("--value", pct + "%");
          tActual.textContent = format(cur);
        });

        audio.addEventListener("ended", () => {
          if (isPlaylist) {
            currentIndex++;
            if (currentIndex < currentPlaylist.length) {
              playTrack(currentPlaylist[currentIndex]);
            } else {
              isPlaylist = false;
              tituloDiv.textContent = "Fin de la playlist";
              sub.textContent = "";
            }
          } else {
            // Si hay forward en el historial (por ejemplo porque el usuario retrocedi√≥ antes), respeta eso
            if (radioIndex < radioHistory.length - 1) {
              radioIndex++;
              const siguiente = radioHistory[radioIndex];
              playTrack(siguiente, { fromHistory: true });
              return;
            }

            // Si no hay forward, generamos aleatorio nuevo
            if (
              Array.isArray(window.cancionesCatalogo) &&
              window.cancionesCatalogo.length > 0
            ) {
              const actual = audio.src.split("/").pop();
              let nueva;
              do {
                nueva =
                  window.cancionesCatalogo[
                    Math.floor(Math.random() * window.cancionesCatalogo.length)
                  ];
              } while (nueva && nueva.ruta.split("/").pop() === actual);

              isPlaylist = false;
              playTrack({
                titulo: nueva.titulo,
                artista: nueva.artista || "",
                ruta: nueva.ruta,
                thumbnail: nueva.thumbnail || "",
              });
            } else {
              tituloDiv.textContent = "No hay canciones disponibles.";
              sub.textContent = "";
            }
          }
        });

        audio.addEventListener("error", () => {
          console.error("audio error", audio.error);
          tituloEl.textContent = "Error de reproducci√≥n";
          sub.textContent = audio.src || "";
        });

        // ---- UI interactions ----
        progreso.addEventListener("input", () => {
          if (!audio) return;
          audio.currentTime = Number(progreso.value);
          const pct =
            isFinite(audio.duration) && audio.duration > 0
              ? (audio.currentTime / audio.duration) * 100
              : 0;
          progreso.style.setProperty("--value", pct + "%");
          tActual.textContent = format(audio.currentTime);
        });

        playPauseBtn.addEventListener("click", () => {
          if (!audio) return;
          if (audio.paused) audio.play();
          else audio.pause();
        });
        audio.addEventListener("play", () => (playPauseBtn.textContent = "‚è∏"));
        audio.addEventListener("pause", () => (playPauseBtn.textContent = "‚ñ∂"));

        // Prev/Next: if no playlist, try to use local catalog as a temp playlist
        function ensurePlaylistFromCatalog() {
          if (
            (!currentPlaylist || !currentPlaylist.length) &&
            Array.isArray(window.cancionesCatalogo) &&
            window.cancionesCatalogo.length
          ) {
            currentPlaylist = window.cancionesCatalogo
              .map((t) => ({
                titulo: t.titulo || "",
                artista: t.artista || "",
                ruta: t.ruta || "",
                thumbnail: t.thumbnail || "",
              }))
              .filter((t) => t.ruta);
            // locate current
            if (audio.src) {
              const curr = audio.src.split("/").pop();
              const idx = currentPlaylist.findIndex(
                (x) => (x.ruta && x.ruta.split("/").pop()) === curr
              );
              currentIndex = idx >= 0 ? idx : 0;
            }
            isPlaylist = true;
            console.info(
              "Usando catalogo local como playlist temporal, len=",
              currentPlaylist.length
            );
          }
        }

        nextBtn.addEventListener("click", () => {
          // Si estamos en playlist, comportamiento normal:
          if (isPlaylist && currentPlaylist.length) {
            if (currentIndex + 1 < currentPlaylist.length) {
              currentIndex++;
              playTrack(currentPlaylist[currentIndex]);
            }
            return;
          }

          // Modo Radio: si hay forward en el historial, vamos a ese forward
          if (radioIndex < radioHistory.length - 1) {
            radioIndex++;
            const siguiente = radioHistory[radioIndex];
            playTrack(siguiente, { fromHistory: true });
            return;
          }

          // si no hay forward, generamos uno nuevo aleatorio
          if (
            Array.isArray(window.cancionesCatalogo) &&
            window.cancionesCatalogo.length > 1
          ) {
            const actual = audio.src.split("/").pop();
            let nueva;
            do {
              nueva =
                window.cancionesCatalogo[
                  Math.floor(Math.random() * window.cancionesCatalogo.length)
                ];
            } while (nueva && nueva.ruta.split("/").pop() === actual);

            isPlaylist = false; // aseguramos modo radio
            playTrack(nueva); // playTrack a√±adir√° esta nueva al historial
          }
        });

        prevBtn.addEventListener("click", () => {
          // Si estamos en playlist ‚Üí comportamiento normal:
          if (isPlaylist && currentPlaylist.length) {
            if (audio.currentTime > 2) {
              audio.currentTime = 0;
            } else if (currentIndex > 0) {
              currentIndex--;
              playTrack(currentPlaylist[currentIndex]);
            }
            return;
          }

          // Modo Radio:
          if (audio.currentTime > 2) {
            audio.currentTime = 0;
            return;
          }

          // Si hay historial previo, retrocedemos en el historial
          if (radioIndex > 0) {
            radioIndex--;
            const anterior = radioHistory[radioIndex];
            // reproducir desde historial (no lo vuelva a pushear)
            playTrack(anterior, { fromHistory: true });
          } else {
            // no hay anterior en historial
            audio.currentTime = 0;
          }
        });

        // volumen
        if (volumenControl && audio) {
          volumenControl.value = audio.volume ?? 1;
          volumenControl.addEventListener("input", () => {
            audio.volume = Number(volumenControl.value);
          });
        }

        // message API to receive playlist or song from other frames
        window.addEventListener("message", (e) => {
          const data = e.data || {};

          // Compatibilidad: data.song puede ser string (ruta) o un objeto con metadata
          if (data.song) {
            let track;
            if (typeof data.song === "string") {
              // string: construimos track e intentamos buscar metadata en el cat√°logo local
              const path = data.song;
              // intentar encontrar en cancionesCatalogo por ruta o por nombre de archivo
              let match = (window.cancionesCatalogo || []).find(
                (x) => x.ruta === path
              );
              if (!match) {
                const filename = path.split("/").pop();
                match = (window.cancionesCatalogo || []).find(
                  (x) => (x.ruta || "").split("/").pop() === filename
                );
              }
              if (match) {
                track = {
                  titulo: match.titulo,
                  artista: match.artista || "",
                  ruta: match.ruta,
                  thumbnail: match.thumbnail || "",
                };
              } else {
                track = {
                  ruta: path,
                  titulo: path
                    .split("/")
                    .pop()
                    .replace(/\.(mp3|wav|ogg)$/i, ""),
                  artista: "",
                  thumbnail: "",
                };
              }
            } else if (typeof data.song === "object") {
              // ya vino con metadata
              track = {
                ruta: data.song.ruta || "",
                titulo: data.song.titulo || "",
                artista: data.song.artista || "",
                thumbnail: data.song.thumbnail || "",
              };
            } else {
              return;
            }

            isPlaylist = false;
            currentPlaylist = [];
            currentIndex = 0;

            // inicializar historial para radio: reemplaza todo el historial con esta canci√≥n como base
            radioHistory = [];
            radioIndex = -1; // playTrack la a√±adir√° (porque fromHistory=false por defecto)

            playTrack(track);
            return;
          }
          // data.playlist: array de tracks + data.index: n√∫mero
          if (Array.isArray(data.playlist) && typeof data.index === "number") {
            currentPlaylist = data.playlist
              .map((t) => ({
                titulo: t?.titulo || "",
                artista: t?.artista || "",
                ruta: t?.ruta || "",
                thumbnail: t?.thumbnail || "",
              }))
              .filter((t) => t.ruta);
            if (!currentPlaylist.length) return;
            playFromPlaylist(data.index);
          }
        });

        // resize parent frameset row to fit this content
        function requestParentResize() {
          try {
            const h = document.documentElement.scrollHeight;
            parent.postMessage({ setPlayerHeight: h }, "*");
          } catch (e) {
            /* may throw if no parent or cross-origin */
          }
        }

        // initial resize (after layout)
        window.addEventListener("load", () => {
          setTimeout(requestParentResize, 80); // slight delay to ensure images loaded
          // --- PRE-CARGAR UNA CANCI√ìN POR DEFECTO ---
          if (
            Array.isArray(window.cancionesCatalogo) &&
            window.cancionesCatalogo.length > 0
          ) {
            const c = window.cancionesCatalogo[0]; // ‚Üê elegimos siempre la primera
            playTrack({
              titulo: c.titulo,
              artista: c.artista || "",
              ruta: c.ruta,
              thumbnail: c.thumbnail || "",
            });
            audio.pause(); // importante ‚Üí no reproducir
            audio.currentTime = 0; // asegurar que queda en 00:00
          }
        });

        // expose for debugging
        window._debugPlayer = { playTrack, currentPlaylist };
      })();
    </script>
  </body>
</html>
